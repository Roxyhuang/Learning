浅谈闭包与应用场景
--
> 本文参考 ：阮一峰大大的博客http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html

>司徒正美大大的博客:http://www.cnblogs.com/rubylouvre/

　　这几天公司里的大神简单的指导了一下我，试着让我明白闭包的原理以及一些应用场景。下面我简单进行一个总结。

 先来说说闭包的概念引用司徒正美大大的解释：
　　

　　**闭包：**是指语法域位于某个特定的区域，具有持续参照（读写）位于该区域内自身范围之外的执行域上的非持久型变量值能力的段落。这些外部执行域的非持久型变量神奇地保留它们在闭包最初定义（或创建）时的值（深连结）。  
　　简单来说，闭包就是在另一个作用域中保存了一份它从上一级函数或作用域取得的变量（键值对），而这些键值对是不会随上一级函数的执行完成而销毁。周爱民说得更清楚，闭包就是“属性表”，闭包就是一个数据块，闭包就是一个存放着“Name=Value”的对照表。就这么简单。但是，必须强调，闭包是一个运行期概念。


**JS中的闭包有两个特点：**
		
1. 作为一个函数变量的一个引用 - 当函数返回时，其处于激活状态。
2. 一个闭包就是当一个函数返回时，一个没有释放资源的栈区。


**现在比较让人认同的闭包实现有如下三种：**  

　　闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。

1. 对象闭包

	  	with(obj){
	   	//这里是对象闭包
	    }`

2. 函数闭包

		(function(){
    	//函数闭包
   		})()

3. catch闭包 （IE不行）

		try{
		//...
		} catch(e) {
		//catch闭包 但IE里不行
		}



**我们为什么需要闭包：**


首先必须理解Javascript特殊的变量作用域。变量的作用域无非就是两种：全局变量和局部变量。

Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。
		
	//内部变量访问外部变量
	var n=999;
	function f1(){
	　　　　alert(n);
	}
	f1(); // 999


另一方面，在函数外部无法读取函数的内部变量

	//
	function f1(){
	　var n=999;
	}
	alert(n); // error

**如何从外部获取函数内部的变量**

正常情况下，办不到， 但是我们可以通过是在函数的内部，再定义一个函数来实现：

        function out(){
            var n = 99;
            function inner(){
                alert(n++);
            }
            return inner
        }
        var result = out();
        result();//99
        result();//100
        result();//101


**闭包的用途**

它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。


在这段代码中，result实际上就是闭包inner函数。它一共运行了三次，第一次的值是99，第二次的值是100,第四次101 这证明了，函数out中的局部变量n一直保存在内存中，并没有在inner调用后被自动清除。

　　为什么会这样呢？原因就在于out是inner的父函数，而inner被赋给了一个全局变量，这导致inner始终在内存中，而inner的存在依赖于out，因此out也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。

五、使用闭包的注意点

1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。


2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。

**with函数闭包**

首先我们先来看看with(object instance)函数
	  
	//with函数闭包
      for(var i = 1; i<10;i++){
          with({i:i})
          document.querySelector('#a'+parseInt(i)).onclick = function(){
                console.log(i);
          }
      }
        
	





try..catch闭包
	
	//	try..catch闭包
      for(var i = 1; i<10;i++){
          try{
              throw i
          } catch (i){
              document.querySelector('#a'+parseInt(i)).onclick = function(){
                  console.log(i);
              }
          }
      }